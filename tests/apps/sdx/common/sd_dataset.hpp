#pragma once

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>


// information contained in each record in the dataset
typedef enum { DATE_FIELD, TIME_FIELD, EPOCH_FIELD, DEVICE_ID_FIELD, TEMP_FIELD, HUMID_FIELD, LIGHT_FIELD, VOLT_FIELD } record_field;
// fields that can be monitored by the user
typedef enum { TEMPERATURE, HUMIDITY, LIGHT, VOLTAGE } monitored_field;

// type of the input records: < date_value, time_value, epoch_value, device_id_value, temp_value, humid_value, light_value, voltage_value>
using sd_record_t = std::tuple<std::string, std::string, int, int, double, double, double, double>;

std::vector<sd_record_t> load_datasaet(const std::string & file_path)
{
    std::vector<sd_record_t> parsed_file;

    std::ifstream file(file_path);
    if (file.is_open()) {
        std::string line;
        while (std::getline(file, line)) {
            int token_count = 0;
            std::vector<std::string> tokens;

            std::istringstream iss(line);
            std::string item;
            while (iss >> item) {
                tokens.push_back(item);
                token_count++;
            }

            // a record is valid if it contains at least 8 values (one for each field of interest)
            if (token_count >= 8) {
                // save parsed file
                sd_record_t r(tokens.at(DATE_FIELD),
                           tokens.at(TIME_FIELD),
                           atoi(tokens.at(EPOCH_FIELD).c_str()),
                           atoi(tokens.at(DEVICE_ID_FIELD).c_str()),
                           atof(tokens.at(TEMP_FIELD).c_str()),
                           atof(tokens.at(HUMID_FIELD).c_str()),
                           atof(tokens.at(LIGHT_FIELD).c_str()),
                           atof(tokens.at(VOLT_FIELD).c_str()));
                parsed_file.push_back(r);
            }
        }
        file.close();
    }
    return parsed_file;
}

template <typename T>
std::vector<T> get_dataset(const std::string & dataset_filepath,
                           const monitored_field field)
{
    std::vector<sd_record_t> parsed_file = load_datasaet(dataset_filepath);
    std::vector<T> dataset;
    dataset.reserve(parsed_file.size());

    int timestamp = 0;
    for (const auto & record : parsed_file) {
        T t;
        t.key = std::get<DEVICE_ID_FIELD>(record);
        switch (field) {
            case TEMPERATURE: t.property_value = std::get<TEMP_FIELD>(record);  break;
            case HUMIDITY:    t.property_value = std::get<HUMID_FIELD>(record); break;
            case LIGHT:       t.property_value = std::get<LIGHT_FIELD>(record); break;
            case VOLTAGE:     t.property_value = std::get<VOLT_FIELD>(record);  break;
        }
        t.timestamp = timestamp++;
        dataset.push_back(t);
    }
    return dataset;
}

// This is an hardcoded vector of results generated by WindFlow with a 4096 inputs
// The app should run with each operator with parallelism = 1
std::vector<record_t> get_golden_results()
{
    std::vector<record_t> results;

    results.push_back(record_t(25, 18.6066f, 19.1495f, 1912));
    results.push_back(record_t(24, 18.8418f, 19.3514f, 2688));
    results.push_back(record_t(20, 20.4392f, 21.0076f, 2613));
    results.push_back(record_t(20, 19.6356f, 20.1587f, 2492));
    results.push_back(record_t(20, 19.4984f, 20.0270f, 2373));
    results.push_back(record_t(20, 19.4102f, 19.9308f, 2334));
    results.push_back(record_t(20, 19.3612f, 19.8769f, 2250));
    results.push_back(record_t(20, 19.2926f, 19.8200f, 2240));
    results.push_back(record_t(20, 19.2240f, 19.7569f, 2150));
    results.push_back(record_t(12, 16.6368f, 17.0700f, 1606));
    results.push_back(record_t(12, 16.4506f, 16.9489f, 1558));
    results.push_back(record_t(12, 16.4114f, 16.9105f, 1493));
    results.push_back(record_t(12, 16.3820f, 16.8753f, 1436));
    results.push_back(record_t(12, 16.3624f, 16.8432f, 1318));
    results.push_back(record_t(12, 16.3134f, 16.7501f, 1218));
    results.push_back(record_t(12, 16.2742f, 16.6932f,  151));
    results.push_back(record_t(12, 16.2154f, 16.6368f,  148));
    results.push_back(record_t(12, 16.1664f, 16.5817f,   84));

    return results;
}